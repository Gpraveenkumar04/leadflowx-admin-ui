import { NextApiRequest, NextApiResponse } from 'next';
import { withApiAuth } from '../../../../lib/auth';
import { spawn } from 'child_process';
import os from 'os';
// Lazy import pg on the server to avoid edge bundling issues
let PgClient: any;
try {
  const pg = require('pg');
  PgClient = pg.Client;
} catch {}

// Simple in-memory status tracker
const status = {
  isRunning: false,
  totalLeads: 0,
  qualifiedLeads: 0,
  lastUpdate: null as string | null,
  startedAt: null as number | null,
};

// Postgres connection from environment (matches docker-compose defaults)
function getPgClient() {
  const connectionString =
    process.env.DATABASE_URL ||
    'postgres://postgres:postgres@localhost:5432/leadflowx';
  if (!PgClient) throw new Error('pg client not available');
  return new PgClient({ connectionString });
}

/**
 * Google Maps Scraper Status API
 * 
 * GET /api/scrapers/google-maps/status
 * Returns the current status of the Google Maps scraper
 */
async function handleGetStatus(req: NextApiRequest, res: NextApiResponse) {
  try {
    // Optionally, read counts from DB
    const client = getPgClient();
    try {
      await client.connect();
      const total = await client.query('SELECT COUNT(*)::int AS c FROM lead_exports');
      const qualified = await client.query(
        "SELECT COUNT(*)::int AS c FROM lead_exports WHERE score IS NOT NULL AND score <> ''"
      );
      status.totalLeads = total.rows?.[0]?.c ?? status.totalLeads;
      status.qualifiedLeads = qualified.rows?.[0]?.c ?? status.qualifiedLeads;
    } catch (e) {
      // ignore DB errors in status
    } finally {
      await client.end().catch(() => {});
    }

    res.status(200).json({
      isRunning: status.isRunning,
      totalLeads: status.totalLeads,
      qualifiedLeads: status.qualifiedLeads,
      lastUpdate: status.lastUpdate,
      runningTime:
        status.startedAt && status.isRunning
          ? `${Math.floor((Date.now() - status.startedAt) / 60000)}m`
          : null,
    });
  } catch (error) {
    console.error('Error fetching Google Maps scraper status:', error);
    res.status(500).json({ error: 'Failed to fetch scraper status' });
  }
}

/**
 * Google Maps Scraper Leads API
 * 
 * GET /api/scrapers/google-maps/leads
 * Returns leads generated by the Google Maps scraper
 */
async function handleGetLeads(req: NextApiRequest, res: NextApiResponse) {
  try {
  const { limit = '25', offset = '0' } = req.query;

    const client = getPgClient();
    await client.connect();
  await client.query("SET search_path TO leadflowx, public");
    const totalRes = await client.query('SELECT COUNT(*)::int AS c FROM lead_exports');
    const rowsRes = await client.query(
      `SELECT lead_id, business_name, city_state_zip, rating, reviews, score, created_at
       FROM lead_exports
       ORDER BY created_at DESC
       LIMIT $1 OFFSET $2`,
      [Number(limit), Number(offset)]
    );
    await client.end();

  const leads = (rowsRes.rows as any[]).map((r: any) => ({
      id: r.lead_id,
      name: r.business_name,
      location: r.city_state_zip,
      rating: r.rating ?? null,
      reviews: r.reviews ?? null,
      score: r.score ?? null,
      scrapedAt: r.created_at,
    }));

    res.status(200).json({
      leads,
      total: totalRes.rows?.[0]?.c ?? leads.length,
      limit: Number(limit),
      offset: Number(offset),
    });
  } catch (error) {
    console.error('Error fetching Google Maps leads:', error);
    res.status(500).json({ error: 'Failed to fetch leads' });
  }
}

/**
 * Start Google Maps Scraper API
 * 
 * POST /api/scrapers/google-maps/start
 * Starts the Google Maps scraper with optional parameters
 */
async function handleStartScraper(req: NextApiRequest, res: NextApiResponse) {
  try {
    // Accept both flat params and a `filters` object. Also accept single string or array values.
    const { location, businessType, userId, maxQualifiedLeads, filters } = req.body;

    // Normalize locations and types into arrays
    const locationsArr: string[] = [];
    const typesArr: string[] = [];
    const pushLocation = (v: any) => { if (!v && v !== 0) return; if (Array.isArray(v)) v.forEach(x => x && locationsArr.push(String(x))); else locationsArr.push(String(v)); };
    const pushType = (v: any) => { if (!v && v !== 0) return; if (Array.isArray(v)) v.forEach(x => x && typesArr.push(String(x))); else typesArr.push(String(v)); };

    pushLocation(location);
    pushType(businessType);
    if (filters) {
      if (filters.location) pushLocation(filters.location);
      if (filters.locations) pushLocation(filters.locations);
      if (filters.businessType) pushType(filters.businessType);
      if (filters.types) pushType(filters.types);
    }

    if (status.isRunning) {
      return res.status(409).json({ error: 'Scraper already running' });
    }

    // Build PowerShell command to reuse the proven E2E script
    // We'll pass US-only and the global cap for qualified leads; optional location and type
    const workspace = process.env.WORKSPACE_PATH || 'c://Dev//LeadFlowX-Enterprise';
    const scriptPath = `${workspace}\\leadflowx-scraper-workers\\googlemaps-scraper\\scripts\\run_e2e.ps1`;

    // Compose args
    const args: string[] = [];
    // Add city/type args for each provided value
    locationsArr.forEach(loc => args.push(`-Cities \"${String(loc).replace(/\"/g, '\\\"')}\"`));
    typesArr.forEach(t => args.push(`-Types \"${String(t).replace(/\"/g, '\\\"')}\"`));
    args.push('-USOnly');
    if (maxQualifiedLeads) {
      args.push(`-MaxQualifiedLeads ${Number(maxQualifiedLeads)}`);
    }

    const psCommand = `& \"${scriptPath}\" ${args.join(' ')}`;

    // Spawn PowerShell so Next API thread doesn't block; we won't stream output for now
    const child = spawn('powershell.exe', ['-NoProfile', '-ExecutionPolicy', 'Bypass', '-Command', psCommand], {
      windowsHide: true,
    });

    status.isRunning = true;
    status.startedAt = Date.now();
    status.lastUpdate = new Date().toISOString();

    child.stdout.on('data', (d) => {
      // naive status update when DB insert lines appear; also update timestamp
      status.lastUpdate = new Date().toISOString();
    });
    child.stderr.on('data', (d) => {
      // keep lastUpdate moving on stderr as well
      status.lastUpdate = new Date().toISOString();
    });
    child.on('exit', async (code) => {
      status.isRunning = false;
      status.startedAt = null;
      status.lastUpdate = new Date().toISOString();
      // refresh counts
      try {
        const client = getPgClient();
        await client.connect();
        const t = await client.query('SELECT COUNT(*)::int AS c FROM lead_exports');
        status.totalLeads = t.rows?.[0]?.c ?? status.totalLeads;
        await client.end();
      } catch {}
    });

    console.log('Started Google Maps scraper with command:', psCommand);
    res.status(200).json({ success: true, message: 'Scraper started' });
  } catch (error) {
    console.error('Error starting Google Maps scraper:', error);
    res.status(500).json({ error: 'Failed to start scraper' });
  }
}

/**
 * Stop Google Maps Scraper API
 * 
 * POST /api/scrapers/google-maps/stop
 * Stops the Google Maps scraper
 */
async function handleStopScraper(req: NextApiRequest, res: NextApiResponse) {
  try {
  // Basic best-effort: stop via orchestrator script if available
  const workspace = process.env.WORKSPACE_PATH || 'c://Dev//LeadFlowX-Enterprise';
  const manageScript = `${workspace}\\leadflowx-scraper-workers\\manage-scrapers.ps1`;
  const cmd = `& \"${manageScript}\" stop googlemaps`;
  spawn('powershell.exe', ['-NoProfile', '-ExecutionPolicy', 'Bypass', '-Command', cmd], { windowsHide: true });

  status.isRunning = false;
  status.startedAt = null;
  status.lastUpdate = new Date().toISOString();

  console.log('Requested Google Maps scraper stop');
  res.status(200).json({ success: true, message: 'Stop signal sent' });
  } catch (error) {
    console.error('Error stopping Google Maps scraper:', error);
    res.status(500).json({ error: 'Failed to stop scraper' });
  }
}

/**
 * Save Google Maps Scraper Configuration API
 * 
 * POST /api/scrapers/google-maps/config
 * Saves the configuration for the Google Maps scraper
 */
async function handleSaveConfig(req: NextApiRequest, res: NextApiResponse) {
  try {
    const config = req.body;
    
    // In production, this would save the config to database or file
    console.log('Saving Google Maps scraper configuration:', config);
    
    res.status(200).json({ success: true, message: 'Configuration saved successfully' });
  } catch (error) {
    console.error('Error saving Google Maps scraper configuration:', error);
    res.status(500).json({ error: 'Failed to save configuration' });
  }
}

/**
 * Export Google Maps Leads API
 * 
 * GET /api/scrapers/google-maps/export
 * Exports leads as CSV
 */
async function handleExportLeads(req: NextApiRequest, res: NextApiResponse) {
  try {
    // Build CSV from DB exports
    const client = getPgClient();
    await client.connect();
  await client.query("SET search_path TO leadflowx, public");
    const rows = await client.query(
      `SELECT lead_id, business_name, city_state_zip, rating, reviews, score, created_at
       FROM lead_exports
       ORDER BY created_at DESC`
    );
    await client.end();

    const header = 'lead_id,business_name,city_state_zip,rating,reviews,score,created_at\n';
    const body = (rows.rows as any[])
      .map((r: any) =>
        [r.lead_id, r.business_name, r.city_state_zip, r.rating ?? '', r.reviews ?? '', r.score ?? '', r.created_at?.toISOString?.() ?? r.created_at]
          .map((v) => (typeof v === 'string' && v.includes(',') ? `"${v.replace(/"/g, '""')}"` : v))
          .join(',')
      )
      .join('\n');
    const csv = header + body;

    res.setHeader('Content-Type', 'text/csv');
    res.setHeader(
      'Content-Disposition',
      `attachment; filename=google-maps-leads-${new Date().toISOString().split('T')[0]}.csv`
    );
    res.status(200).send(csv);
  } catch (error) {
    console.error('Error exporting Google Maps leads:', error);
    res.status(500).json({ error: 'Failed to export leads' });
  }
}

async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { method } = req;
  
  switch (method) {
    case 'GET':
      if (req.url?.includes('/leads')) {
        return handleGetLeads(req, res);
      } else if (req.url?.includes('/export')) {
        return handleExportLeads(req, res);
      } else {
        return handleGetStatus(req, res);
      }
    case 'POST':
      if (req.url?.includes('/start')) {
        return handleStartScraper(req, res);
      } else if (req.url?.includes('/stop')) {
        return handleStopScraper(req, res);
      } else if (req.url?.includes('/config')) {
        return handleSaveConfig(req, res);
      } else {
        res.status(400).json({ error: 'Invalid action' });
        return;
      }
    default:
      res.setHeader('Allow', ['GET', 'POST']);
      res.status(405).end(`Method ${method} Not Allowed`);
  }
}

export default withApiAuth(handler);
